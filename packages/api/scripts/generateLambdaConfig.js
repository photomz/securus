/* eslint-disable no-param-reassign */
/* eslint-disable no-template-curly-in-string */
const fs = require('fs');
const path = require('path');
const klaw = require('klaw');
const yaml = require('js-yaml');
const { promisify } = require('util');

const SEARCHPATH = process.argv[2] || '..';

const writeYaml = async (filepath, obj) =>
  promisify(fs.writeFile)(
    filepath,
    `# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY. RUN scripts/generateLambdaConfig TO REGENERATE\n\n${yaml.dump(
      obj
    )}`,
    {
      encoding: 'utf8',
    }
  );
const capitalise = (str) => str.charAt(0).toUpperCase() + str.slice(1);

const filter = (item) => {
  const basename = path.basename(item);
  return (
    (basename === '.' || basename[0] !== '.') &&
    basename !== 'node_modules' &&
    basename !== 'venv' &&
    basename !== '__pycache__'
  );
};

const describeDataSource = (funcName) => ({
  Type: 'AWS::AppSync::DataSource',
  Properties: {
    ApiId: '${self:custom.appsyncId}',
    Description: `${funcName} lambda handler for \${self:service}, securus`,
    LambdaConfig: {
      LambdaFunctionArn: {
        'Fn::GetAtt': [`${capitalise(funcName)}LambdaFunction`, 'Arn'],
      },
    },
    ServiceRoleArn: {
      'Fn::GetAtt': ['AppSyncLambdaRole', 'Arn'],
    },
    Type: 'AWS_LAMBDA',
    Name: `${funcName}Lambda`,
  },
});

const describeResolver = (funcName, typeName) => ({
  Type: 'AWS::AppSync::Resolver',
  Properties: {
    ApiId: '${self:custom.appsyncId}',
    FieldName: funcName,
    RequestMappingTemplate:
      '${file(resources/api/variableResolver.js):requestMappingTemplate}',
    ResponseMappingTemplate:
      '${file(resources/api/variableResolver.js):responseMappingTemplate}',
    TypeName: typeName,
    DataSourceName: {
      'Fn::GetAtt': [`${capitalise(funcName)}DataSource`, 'Name'],
    },
  },
});

const describeFunction = (funcName, funcPath, funcLang) => ({
  ...(funcLang === 'py'
    ? {
        /* The default way Serverless structures Lambda distribution packages is not inherently compatible with the way
         * Lambda (or Python, for that matter) expects the package to be structured.
         * We split the function into its module path and file name handler so Python imports work as expected
         * https://medium.com/@nate_mitchell/serverless-packaging-user-defined-python-modules-41808776eae0
         * https://github.com/n473-/examples/blob/master/aws-python-simple-http-endpoint/serverless.yml
         */
        handler: funcPath.split('/').slice(-1)[0],
        module: funcPath.split('/').slice(0, -1).join('/'),
        // Python lambdas run data and compute intensive tasks - give max timeout
        // https://stackoverflow.com/questions/43577746/aws-lambda-task-timed-out
        timeout: 15 * 60,
        memorySize: 4096,
      }
    : {
        handler: funcPath,
      }),
  role: {
    'Fn::GetAtt': ['LambdaRole', 'Arn'],
  },
  tags: {
    project: 'securus',
    service: '${self:service}',
    component: 'lambda',
  },
  runtime: funcLang === 'py' ? 'python3.8' : 'nodejs14.x',
});

/**
 * Traverse given path and find all index.ts files
 * For each ts file:
 * 	Create lambda function
 * 	Create lambda data source
 * 	Create lambda mapping
 * @param searchPath string
 * @param writePath string
 */
const generateLambdaConfig = (
  searchPath = SEARCHPATH,
  writePath = `${searchPath}/resources/api`
) => {
  // Function executes with script/ dirname, must 'cd' back to root
  searchPath = path.join(__dirname, '..', searchPath);
  writePath = path.join(__dirname, '..', writePath);
  let functionConfig = {};
  let resourceConfig = {};

  klaw(searchPath, { filter })
    .on('data', ({ path: absPath }) => {
      // eslint-disable-next-line prefer-destructuring
      const relativePath = absPath.replace(`${searchPath}/`, ''); // Absolute to relative path
      const language = absPath.split('.').slice(-1)[0];

      if (
        !relativePath ||
        !['mutation.ts', 'query.ts', 'subscription.ts', 'index.py'].includes(
          path.basename(relativePath)
        )
      ) {
        return;
      }
      // Gets name of folder encapsulating index.ts as function name
      const handlerPath = relativePath
        .replace('.py', '.handler')
        .replace('.ts', '.handler');

      const pathArr = relativePath.split('/');
      const name = pathArr.slice(-2, -1)[0];
      const typeName =
        pathArr.slice(-1)[0].split('.')[0] === 'mutations'
          ? 'Mutation'
          : 'Query';

      resourceConfig = {
        [`${capitalise(name)}DataSource`]: describeDataSource(name),
        [`${capitalise(name)}Resolver`]: describeResolver(name, typeName),
        ...resourceConfig,
      };
      functionConfig = {
        [name]: describeFunction(name, handlerPath, language),
        ...functionConfig,
      };
    })
    .on('error', (err, { filepath }) => {
      throw new Error(`At ${filepath}: ${err}`);
    })
    .on('end', async () => {
      await writeYaml(`${writePath}/functions.yml`, functionConfig);
      await writeYaml(`${writePath}/appsync.yml`, {
        Resources: resourceConfig,
      });
    });
};

generateLambdaConfig();
module.exports = generateLambdaConfig;
